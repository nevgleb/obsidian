SQL-инъекция на основе ошибок относится к случаям, когда вы можете использовать сообщения об ошибках для извлечения или вывода конфиденциальных данных из базы данных даже в [[Blind SQL injection | слепых контекстах]]. Возможности зависят от конфигурации базы данных и типов ошибок, которые вы можете вызвать:

- Возможно, вам удастся заставить приложение вернуть конкретный ответ об ошибке на основе результата логического выражения. Вы можете использовать это так же, как условные ответы.
- Вы можете запускать сообщения об ошибках, которые выводят данные, возвращаемые запросом. Это эффективно превращает невидимые уязвимости SQL-инъекции в видимые. Для получения дополнительной информации см. раздел Извлечение конфиденциальных данных с помощью подробных сообщений об ошибках SQL.

## Использование слепой SQL-инъекции путем запуска условных ошибок

Некоторые приложения выполняют SQL-запросы, но их поведение не меняется, независимо от того, возвращает ли запрос какие-либо данные. Метод, описанный в [[Blind SQL injection | слепых инъекциях]], не сработает, потому что внедрение различных логических условий не влияет на ответы приложения.

Часто можно заставить приложение возвращать другой ответ в зависимости от того, произошла ли ошибка SQL. Вы можете изменить запрос таким образом, чтобы он вызывал ошибку базы данных, только если условие истинно. Очень часто необработанная ошибка, выдаваемая базой данных, вызывает некоторое различие в ответе приложения, например, сообщение об ошибке. Это позволяет вам сделать вывод об истинности введенного условия.

## Использование слепой SQL-инъекции путем запуска условных ошибок - Продолжение

Чтобы увидеть, как это работает, предположим, что по очереди отправляются два запроса:

```
xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a 
xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a
```

Эти входные данные используют `CASE` ключевое слово для проверки условия и возвращают другое выражение в зависимости от того, является ли это выражение истинным:

- При первом вводе `CASE` выражение принимает значение `'a'`, что не вызывает никакой ошибки.
- При втором вводе он принимает значение `1/0`, что вызывает ошибку деления на ноль.

Если ошибка вызывает разницу в HTTP-ответе приложения,  можно использовать это, чтобы определить, является ли введенное условие истинным.

Используя этот метод, вы можете извлекать данные, тестируя по одному символу за раз:

`xyz' AND (SELECT CASE WHEN (Username = 'Administrator' AND SUBSTRING(Password, 1, 1) > 'm') THEN 1/0 ELSE 'a' END FROM Users)='a`

## Извлечение конфиденциальных данных с помощью подробных сообщений об ошибках SQL

Неправильная настройка базы данных иногда приводит к появлению подробных сообщений об ошибках. Они могут предоставлять информацию, которая может быть полезна злоумышленнику.

Иногда вы можете заставить приложение сгенерировать сообщение об ошибке, содержащее некоторые данные, возвращаемые запросом. Это эффективно превращает уязвимость, которая в противном случае была бы скрытой при SQL-инъекции, в видимую.

Для достижения этой цели можно использовать функцию `CAST()`. Она позволяет преобразовывать один тип данных в другой. Например, представьте запрос, содержащий следующее утверждение:

`CAST((SELECT example_column FROM example_table) AS int)`

Часто данные, которые вы пытаетесь прочитать, представляют собой строку. Попытка преобразовать это в несовместимый тип данных, такой как an `int`, может вызвать ошибку, подобную следующей:

`ERROR: invalid input syntax for type integer: "Example data"`

Этот тип запроса также может быть полезен, если ограничение по символам не позволяет запускать условные ответы.

