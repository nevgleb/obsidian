Подделка запросов на стороне сервера - это уязвимость веб-безопасности, которая позволяет злоумышленнику заставить серверное приложение отправлять запросы в непреднамеренное местоположение.

При типичной SSRF-атаке злоумышленник может заставить сервер установить соединение с внутренними службами в инфраструктуре организации. В других случаях он может заставить сервер подключиться к произвольным внешним системам. Это может привести к утечке конфиденциальных данных, таких как учетные данные для авторизации.

## Каковы последствия SSRF-атак?

Успешная SSRF-атака часто может привести к несанкционированным действиям или доступу к данным внутри организации. Это может быть в уязвимом приложении или в других внутренних системах, с которыми приложение может взаимодействовать. В некоторых ситуациях уязвимость SSRF может позволить злоумышленнику выполнить произвольную команду.

[[Эксплойт]] SSRF, вызывающий подключения к внешним системам сторонних производителей, может привести к дальнейшим вредоносным атакам. Может показаться, что они исходят от организации, на которой размещено уязвимое приложение.

## Распространенные SSRF-атаки

SSRF-атаки часто используют отношения доверия для усиления атаки из уязвимого приложения и выполнения несанкционированных действий. Эти отношения доверия могут существовать по отношению к серверу или по отношению к другим серверным системам в той же организации.

Почему приложения ведут себя таким образом и неявно доверяют запросам, поступающим с локального компьютера? Это может возникать по разным причинам:

- Проверка контроля доступа может быть реализована в другом компоненте, который находится перед сервером приложений. Когда выполняется обратное подключение к серверу, проверка обходится.
- В целях аварийного восстановления приложение может разрешать административный доступ без входа в систему любому пользователю, входящему с локального компьютера. Это позволяет администратору восстановить систему, если он потеряет свои учетные данные. Предполагается, что только полностью доверенный пользователь может приходить непосредственно с сервера.
- Административный интерфейс может прослушивать порт с другим номером, отличным от основного приложения, и может быть недоступен напрямую для пользователей.

Такого рода доверительные отношения, при которых запросы, исходящие с локального компьютера, обрабатываются иначе, чем обычные запросы, часто превращают SSRF в критическую [[Уязвимости | уязвимость]]. 

## SSRF-атаки на другие серверные системы

В некоторых случаях сервер приложений может взаимодействовать с серверными системами, к которым пользователи не имеют прямого доступа. Эти системы часто имеют частные IP-адреса, не поддающиеся маршрутизации. Серверные системы обычно защищены сетевой топологией, поэтому они часто имеют более слабый уровень безопасности. Во многих случаях внутренние серверные системы содержат конфиденциальную функциональность, доступ к которой может получить без аутентификации любой, кто способен взаимодействовать с системами.

### SSRF с фильтрами ввода на основе черного списка

Некоторые приложения блокируют входные данные, содержащие имена хостов, такие как `127.0.0.1` и `localhost`, или конфиденциальные URL-адреса, такие как `/admin`. В этой ситуации часто можно обойти фильтр, используя следующие методы:

- Используйте альтернативное представление IP-адреса `127.0.0.1`, такое как `2130706433`, `017700000001` или `127.1`.
- Зарегистрируйте свое собственное доменное имя, которое преобразуется в `127.0.0.1`. Вы можете использовать `spoofed.burpcollaborator.net` для этой цели.
- Запутывает заблокированные строки, используя кодировку URL или изменение регистра.
- Укажите контролируемый вами URL-адрес, который перенаправляется на целевой URL-адрес. Попробуйте использовать разные коды перенаправления, а также разные протоколы для целевого URL-адреса. Например, было показано, что переключение с `http:` на `https:` URL во время перенаправления позволяет обойти некоторые фильтры, защищающие от SSRF.
### SSRF с фильтрами ввода на основе белого списка

Некоторые приложения допускают только совпадающие входные данные, белый список разрешенных значений. Фильтр может искать совпадение в начале входных данных или внутри них. Возможно, вам удастся обойти этот фильтр, используя несоответствия в синтаксическом анализе URL.

Спецификация URL содержит ряд функций, которые, вероятно, будут упущены из виду, когда URL реализуют специальный синтаксический анализ и проверку с использованием этого метода:

- Вы можете вставлять учетные данные в URL-адрес перед именем хоста, используя символ `@`. Например:
    
    `https://expected-host:fakepassword@evil-host`
- Вы можете использовать символ `#` для обозначения фрагмента URL. Например:
    
    `https://evil-host#expected-host`
- Вы можете использовать иерархию именования DNS для ввода необходимых данных в полное DNS-имя, которым вы управляете. Например:
    
    `https://expected-host.evil-host`
- Вы можете кодировать символы в URL-кодировке, чтобы запутать код, анализирующий URL. Это особенно полезно, если код, реализующий фильтр, обрабатывает символы в URL-кодировке иначе, чем код, выполняющий внутренний HTTP-запрос. Вы также можете попробовать двойное кодирование символов; некоторые серверы рекурсивно расшифровывают URL-адреса получаемых ими входных данных, что может привести к дальнейшим расхождениям.
- Вы можете использовать комбинации этих методов вместе.

### Обход фильтров SSRF с помощью открытого перенаправления

Иногда бывает возможно обойти защиту на основе фильтров, используя уязвимость открытого перенаправления.

В предыдущем примере представьте, что отправленный пользователем URL-адрес строго проверяется для предотвращения злонамеренного использования поведения SSRF. Однако приложение, URL-адреса которого разрешены, содержит уязвимость с открытым перенаправлением. При условии, что API, используемый для выполнения внутреннего HTTP-запроса, поддерживает перенаправления, вы можете создать URL-адрес, который удовлетворяет фильтру и приводит к перенаправлению запроса к желаемой внутренней цели.
